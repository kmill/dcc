\documentclass[11pt]{article}

\usepackage{amsmath, amsfonts,amssymb,amsthm}
\usepackage{fullpage}

\title{6.035 Project 4 Writeup}
\author{Kyle Miller, Alec Thomson, Patrick Hulin, Steven Valdez}
\begin{document}
\maketitle

\section {Overview}

\section {Division of Work}

\section {Expression Unflattener}

The purpose of the expression unflattener is to return the mid-ir to ``Tree-Form'' after CSE is performed while maintaining the benefits gained from CSE so that Instruction Selection Peephole Optimizations can be easily performed by the code generator. The design, implementation, and test plan of the unflattener are described below. 

\subsection{Design of Expression Unflattener}

Our design first makes use of the liveness information
provided by dead-code elimination to determine which variables are
live at any given block in the mid-ir control flow graph. Once this
information is obtained, unflattening can be performed at the block
level.\\


\noindent Each block is then re-written according to the following algorithm: 

\begin{verbatim}
UnflattenBlock(block):

1. Determine the number of uses of each variable in this block 
2. Determine the reaching definitions of each variable defined in this
block
3. For each variable of each expression in this block: 
   1. If the variable is not live at any of this blocks successors 
      AND the variable is only used once in this entire block 
      (i.e. this is the only use)
      AND the variable is mapped to a reaching definition from this block 
   4. THEN replace the use of this variable with the expression from
its reaching definition
\end{verbatim}

\noindent The UnflattenBlock function is run on the same block until that block
reaches a fixed point. The general purpose of this algorithm is to
discover variables that are ``temporary'' in a given block and to replace
their uses with the expressions they were assigned to represent during
the flattening phase. Since the algorithm doesn't consider a variable
``temporary'' if it is used more than once (or if it is live in a
successor of this block), the benefits of CSE should be preserved
while the mid-ir is returned to tree-form. 

\subsection{Implementation of Expression Unflattener}

The expression unflattener is implemented in the Dataflow.hs source file. The algorithm is roughly the same as the one described above with some augmentations to allow for easy fixed point detection. 

The first thing the implementation does is use the Hoopl liveness analysis implemented as part of the previous project to obtain a factbase of the live variables at the start of every block. Next it maps the ``UnflattenBlock'' function across every block in the graph to obtain a new graph with every block flattened to a fixed point. The ``UnflattenBlock'' function will call itself recursively if it detects that it is returning a changed graph as a result of its modifications. When ``UnflattenBlock'' no longer has an effect, the algorithm terminates. 

After unflattening every block in the graph, the algorithm then concludes by performing dead code elimination again to eliminate assignments to temporaries that are no longer being used. 

\subsection{Experimental Results of Expression Unflattener}

The unflattener passes our entire test suite and appears to work
correctly. The figures below show the unflattener operating on a
simple program. The second figure shows how the unflattener maintains
the benefits obtained from CSE. 

% TODO: Put the before and after graphs right here for unflattentest1 and unflattentest2

\section{Loop Parallelizer}

The loop parallelizer splits the control flow into multiple threads
for loops with expensive bodies with no inter-run dependencies.
It should parallelize nearly every parallelizable loop, as it uses a
fairly advanced method.

\subsection{Design}

\subsection{Implementation}

% stuff about loop analysis

The parallelizer makes use of a new instruction in our mid-ir,
"Parallel". This instruction is inserted before the loop, and the
loop's induction variable update instructions are modified in order to
only execute some of the loop's executions in each run.

% stuff about code generation

\subsection{Results}

% add some graphs

\section{Loop Invariant Code Motion}

Loop Invariant Code Motion (LICM) moves loop-invariant instructions
out of loops so they execute less frequently. The optimization is
important because some compiler-generated instructions are
loop-invariant and get repeated over and over, which is clearly a
waste of resources. The implementation consists of a dataflow analysis
and a non-local rewrite function: the rewrite function uses the State
monad to ensure that instructions only get moved once.

\section{Conclusion}


\end{document}
