\documentclass[11pt]{article}

\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{fullpage}

\title{6.035 Project 1}
\author{Kyle Miller, Patrick Hulin, Alec Thomson, Steven Valdez}
\begin{document}
\maketitle

\section{Overview} 

For this project, we extended the decaf scanner/parser created in project 0 to check for semantic errors and to build a useful intermediate representation for code generation. The project is split up into two distinct parts that can occur in parralel: semantic checking and IR generation. 

When ``--target inter'' is specified on the command line, the compiler will perform all semantic checks on the input program. If there are no semantic errors and ``--debug'' is specified, the compiler will then generate a ``Hybrid AST'' (outlined in Section 3) and print this IR to the terminal. 

\section{Semantic Checker}

\section{IR for Code Generation}

After finishing all Semantic Checks with the Unification system, the compiler creates a new IR called the ``Hybrid AST'' designed for ease of use for code generation. The Hybrid AST' defined in SymbolTable.hs is a hybrid of an abstract syntax tree and a symbol table. It is constructed very similarly to the AST defined in AST.hs with the addition that each node in the AST now contains a reference to the ``Symbol Environment''  the node has access to. 

The Symbol Environments are types that contain information about all symbols available at a certain portion of the program. Each Symbol Environment is composed of a Haskell Map mapping names to symbol information and a pointer to a Parent Symbol Environment. It is important to note that since Symbol Environments are deeply connected with the AST, a Symbol Environment \emph{does not} contain a reference to any of its child Symbol Environments. If that information is needed, then the AST will have to be navigated to find the child Symbol Environment, which will then have a reference to its parent Symbol Environment. We chose to design the IR this way for greater simplicity. We believe this decision is correct because a node in the program would normally not have any access to symbols declared in a child environment, so providing this information in the Symbol Environments would serve no useful purpose. 

The Hybrid AST is created directly from the AST generated by the parser. Since the Hybrid AST is only created after the program has passed all semantic checks, it operates under the assumption that there are no semantic errors. The Haskell typeclass ``HybridAST'' defines a function called ``createHybridAST'' with type 
\begin{verbatim}
createHybridAST :: SymbolEnv -> a -> b
\end{verbatim} 

SymbolTable.hs then defines an instance of HybridAST for each type representing a node in the AST (from AST.hs) that transforms a node of that type into a corresponding hybrid node that contains the SymbolEnv information. The createHybridAST function also handles creating and populatin the ``SymbolEnvironments''.

For printing purposes the only nodes in the Hybrid AST that print their corresponding Symbol Environments are the nodes that derive a new symbol environment (such as method decls, blocks, and for statements). 

\section{Test Plan}



\end{document}
